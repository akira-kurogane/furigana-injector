<html>
<head>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="server_selector_obj.js"></script>
<script type="text/javascript">
var serverUrl = null;	//Will be set once serverSelector completes it's test loop.
var wwwjdicServerURL = null;
var tabPorts = [];	//manually kept list of tabs that connect.

var defaultIconIdx = 0;
var processedIconIdx = 1;
var disabledIconIdx = 2;
var processingIconIdx = 3;

if (!localStorage) 
	console.log("Error: localStorage not available to background page. Has local storage been disabled in this instance of Chrome?");

if (localStorage.getItem("user_kanji_list") === null) {
	console.log("The localStorage \"user_kanji_list\" value was null. It will be initialised to the installation default list.");
	var defaultUserKanjiList = "日一国会人年大十二本中長出三同時政事自行社見月分議後前民生連五発間対上部東者党地合市業内相方四定今回新場金員九入選立開手米力学問高代明実円関決子動京全目表戦経通外最言氏現理調体化田当八六約主題下首意法不来作性的要用制治度務強気小七成期公持野協取都和統以機平総加山思家話世受区領多県続進正安設保改数記院女初北午指権心界支第産結百派点教報済書府活原先共得解名交資予川向際査勝面委告軍文反元重近千考判認画海参売利組知案道信策集在件団別物側任引使求所次水半品昨論計死官増係感特情投示変打男基私各始島直両朝革価式確村提運終挙果西勢減台広容必応演電歳住争談能無再位置企真流格有疑口過局少放税検藤町常校料沢裁状工建語球営空職証土与急止送援供可役構木割聞身費付施切由説転食比難防補車優夫研収断井何南石足違消境神番規術護展態導鮮備宅害配副算視条幹独警宮究育席輸訪楽起万着乗店述残想線率病農州武声質念待試族象銀域助労例衛然早張映限親額監環験追審商葉義伝働形景落欧担好退準賞訴辺造英被株頭技低毎医復仕去姿味負閣韓渡失移差衆個門写評課末守若脳極種美岡影命含福蔵量望松非撃佐核観察整段横融型白深字答夜製票況音申様財港識注呼渉達";
	localStorage.setItem("user_kanji_list", defaultUserKanjiList);
}
var userKanjiRegexp = new RegExp("[" + localStorage.getItem("user_kanji_list") + "]");

if (localStorage.getItem("include_link_text") === null) {
	console.log("The localStorage \"include_link_text\" value was null. It will be initialised to true.");
	localStorage.setItem("include_link_text", true);	//the default value for including links
}
if (localStorage.getItem("show_translations") === null) {
	console.log("The localStorage \"show_translations\" value was null. It will be initialised to false.");
	localStorage.setItem("show_translations", false);	//the default value for including links
}

//serverSelector defined in server_selector_obj.js. Selects a working serverUrl asynchronously.
serverSelector.startTestLoop(
	/*These URLs must match URL patterns in the "permissions" item in the manifest file. */
	[ "http://fi.yayakoshi.net/furiganainjector", "http://fi2.yayakoshi.net/furiganainjector" ], 
	confirmServerUrl, onNoServerFound, "mod_furiganainjector");

/*****************
 *	Functions
 *****************/
function confirmServerUrl(svrUrl) {
	serverUrl = svrUrl;
	console.log("FuriganaInjector service at " + svrUrl + " confirmed");
	/* TODO re-enable the below when timed service checks are implemented
	chrome.windows.getCurrent(function(currentWindow) {
		chrome.tabs.getSelected(currentWindow.id, function(currTab) {
			if (tabPorts && tabPorts[currTab.id])
				tabPorts[currTab.id].postMessage({message: "serverconfirmed"}); 
		});
	});*/
	//Now find a WWWJDIC server
	serverSelector.startTestLoop(
		[ "http://www.csse.monash.edu.au/~jwb/cgi-bin/wwwjdic.cgi", "http://ryouko.imsb.nrc.ca/cgi-bin/wwwjdic", 
			"http://jp.msmobiles.com/cgi-bin/wwwjdic", "http://www.aa.tufs.ac.jp/~jwb/cgi-bin/wwwjdic.cgi", 
			"http://wwwjdic.sys5.se/cgi-bin/wwwjdic.cgi", "http://www.edrdg.org/cgi-bin/wwwjdic/wwwjdic"],
		confirmWWWJDICServer, onNoWWWJDICServerFound);
}

function onNoServerFound() {
	console.log("Error: none of the servers could be connected to.");
}

function confirmWWWJDICServer(svrUrl) {
	wwwjdicServerURL = svrUrl;
	console.log("WWWJDIC service at " + svrUrl + " confirmed");
}

function onNoWWWJDICServerFound() {
	console.log("Error: none of the WWWJDIC servers could be connected to.");
}

function startFuriganizeAJAX(stringsHash, tabPort, keepAllRuby) {
	if (!serverUrl) {
		console.log("Programming error: startFuriganizeAJAX() called before serverUrl confirmed.");
		return;
	}
	var postData = "";
	//Todo: send as JSON instead?
	for (key in stringsHash)
		postData += "&" + key + "=" + encodeURIComponent(stringsHash[key]);
	postData = postData.substr(1);
	var xhr = new XMLHttpRequest();
	xhr.replyTabPort = tabPort;	//adding custom property to known where to reply to.
	xhr.keepAllRuby = keepAllRuby;
	xhr.onreadystatechange = furiganizeAJAXStateChangeHandler; // Implemented elsewhere.
	xhr.onerror = function(error) {
		console.log("XHR error during startFuriganizeAJAX(): " + JSON.stringify(error));
	};
	xhr.open("POST", serverUrl, true);
	xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	//xhr.setRequestHeader("Content-Length", postData.length); //Apparently this is illegal for chrome
	xhr.send(postData);
	xhr.requestTimer = setTimeout(function(xhr) { 	//N.B. passing the current xhr reference as a timeout parameter to avoid aborting a different XHR sent in the meantime.
			xhr.timedOut = true; 
			xhr.abort(); 
		}, 2000 + (postData.length / 10), xhr);	//e.g. a 33kb post request will get 5.3secs.
}

function furiganizeAJAXStateChangeHandler() {
	if(this.readyState == 4) {
		clearTimeout(this.requestTimer);
		if (this.status == 200) {
			var returnData = JSON.parse(this.responseText);
			if (!this.keepAllRuby) {
				for (key in returnData)
					returnData[key] = stripRubyForSimpleKanji(returnData[key]);
			}
			if (!this.replyTabPort.jqueryIncluded) {
				chrome.tabs.executeScript(this.replyTabPort.tab.id, {file: "jquery.js"/*, allFrames: false*/});
				this.replyTabPort.jqueryIncluded = true;
			}
			this.replyTabPort.postMessage({furiganizedTextNodes: returnData});
			if (!this.replyTabPort.wwwjdicJSAndCSSIncluded && JSON.parse(localStorage.getItem("show_translations"))) {
				chrome.tabs.executeScript(this.replyTabPort.tab.id, {file: "activate_wwwjdic_lookup.js"/*, allFrames: false*/});
				chrome.tabs.insertCSS(this.replyTabPort.tab.id, {file: "ruby_gloss.css"/*, allFrames: false*/});
				this.replyTabPort.wwwjdicJSAndCSSIncluded = true;
			}
		} else if (this.timedOut) {
			this.replyTabPort.postMessage({message: "xhr_request_timeout", status: this.status});
		} else {
			this.replyTabPort.postMessage({message: "xhr_request_failed", status: this.status});
		}
	}
}

function stripRubyForSimpleKanji(origStr) {
	if (!origStr)	//Can happen when server fails and sends bad response?
		return origStr;
	var newStr = "";
	var offset = 0;
	var currRubyBeginOffset = origStr.indexOf("<ruby>", 0);
	if (currRubyBeginOffset < 0)
		return origStr;
var safetyCtr = 0;
	while (currRubyBeginOffset >= 0 && safetyCtr < 100) {
		rubySubstr = origStr.substring(currRubyBeginOffset, origStr.indexOf("</ruby>", currRubyBeginOffset) + 7);
		if (hasOnlySimpleKanji(rubySubstr)) {
			newStr += origStr.substring(offset, currRubyBeginOffset);
			newStr += rubySubstr.replace(
				/<ruby>(?:<rb>)?([^<]*)(?:<\/rb>)?(\s*)(?:<r[pt]>[^<]*<\/r[pt]>)*(\s*)<\/ruby>/, 
				"$1$2$3", "i");
			offset = currRubyBeginOffset + rubySubstr.length;
		}
		currRubyBeginOffset = origStr.indexOf("<ruby>", currRubyBeginOffset + 1);
safetyCtr++;
	}
	newStr += origStr.substring(offset);
	return newStr;
}

function hasOnlySimpleKanji(rubySubstr) {
	var foundKanji = rubySubstr.match(/[\u3400-\u9FBF]/g);
	if (foundKanji) {
		for (var x = 0; x < foundKanji.length; x++) {
			if (!userKanjiRegexp.exec(foundKanji[x]))
				return false;
		}
	} else {
		return null;
	}
	return true;
}

function utf8_encode (string) {
	string = string.replace(/\r\n/g,"\n");
	var utftext = "";
	for (var n = 0; n < string.length; n++) {
		var c = string.charCodeAt(n);
		if (c < 128) {
			utftext += String.fromCharCode(c);
		} else if((c > 127) && (c < 2048)) {
			utftext += String.fromCharCode((c >> 6) | 192);
			utftext += String.fromCharCode((c & 63) | 128);
		} else {
			utftext += String.fromCharCode((c >> 12) | 224);
			utftext += String.fromCharCode(((c >> 6) & 63) | 128);
			utftext += String.fromCharCode((c & 63) | 128);
		}
	}
	return utftext;
}

function getWWWJDICEntry(port, word, yomi, temp_id, dict) {
	var cachedGloss = localStorage.getItem("WWWJDIC_GLOSS-" + word + "-" + yomi);
	if (cachedGloss) {
		//Todo: track how often student looks at each word, remind them if they're being too lazy?
		var messageData = {message: "wwwjdic_gloss", gloss: cachedGloss, 
			formattedGloss: formatGloss(cachedGloss), temp_id: temp_id};
		port.postMessage(messageData);
		return;
	} 
	//Else - request from WWWJDIC servers
	//See http://www.csse.monash.edu.au/~jwb/wwwjdicinf.html#backdoor_tag for explanation of query flags
	//1 = EDICT (vs P = expanded text gloss dict), Z = raw output, U = UTF8, Q = 'exact match'
	dict = dict ? dict : "1";	//Use EDICT as the default dictionary.
	$.ajax({
		url: wwwjdicServerURL + "?" + dict + "ZUQ" + escape(utf8_encode(word)),
		beforeSend: function(coreXHRObj){
				coreXHRObj.setRequestHeader("FIExtraFeatures","dictionary_form_attributes");
		},
		type: "get",
		success: getWWWJDICEntryCallback,
		error: function() {
			console.log("Ajax request for WWWJDIC entry failed: " + textStatus);
		},
		port: port,
		word: word,
		yomi: yomi,
		temp_id: temp_id,
		dict: dict
	});
}

function getWWWJDICEntryCallback(data/*, textStatus, xhr*/) {
	var thisXHR = this;
	var formattedResults = data.replace(/\n/g,'\t').match(/<pre>(.+)<\/pre>/);
	if (!formattedResults) {
		if (thisXHR.dict == "1"/*Edict*/) { //Edict is the first, default dictionary that is searched.
			//Search again using "P", the expanded text gloss dict
			getWWWJDICEntry(thisXHR.port, thisXHR.word, thisXHR.yomi, thisXHR.temp_id, "P");
		} else {	//Stop searching
if (thisXHR.dict != "P") console.log("Programming error: dict \"" + thisXHR.dict + "\" encountered in getWWWJDICEntryCallback()");
			var messageData = {message: "wwwjdic_gloss", gloss: null, temp_id: thisXHR.temp_id};
			thisXHR.port.postMessage(messageData);
		}
	} else {
		var resultLines = formattedResults[1].replace(/^\s*|\s*$/, "").split('\t');
		var matchingGloss = null;
		//The pattern is sometimes several alternate kanji forms e.g. "曇り(P); 曇 [くもり] /(pos) gloss/gloss/...."
		var entryRegex = new RegExp("^(?:[^;]+;)*" + thisXHR.word + "(?:[\\(\\)a-zA-Z])?(?:;[^;]+)* \\[" + thisXHR.yomi +"\\]\\s+(.+)$");	//(?: [A-Z][A-Z][12]?)?
		//Devnote: unhandled exception case - two [よみ] fields, such as 
		//  "昭島 [あきしま] Akishima (p,s) [あきじま] Akijima (s)" from ENAMDICT.
		for (var x = 0; x < resultLines.length; x++) {
			//var entryParts = resultLines[x].match(/^(\S+)\s+\[([^\]]+)\]\s+(.+)$/);
			var entryParts = entryRegex.exec(resultLines[x]);
			if (entryParts) {
//Todo replace the error logging below with a break once confirmed the duplicates error only happens rarely.
if (matchingGloss) console.log("Error: " + thisXHR.word + "-" + thisXHR.yomi + " matched to \"" + entryParts[1] + "\" as well as \"" + matchingGloss + "\""); else
				matchingGloss = entryParts[1];
				if (thisXHR.dict == "P")
					matchingGloss = matchingGloss.replace(/ ?[A-Z][A-Z]\\?\d?\/?$/, "");	//trim dictionary code off.
			}
		}
		if (matchingGloss) {
			var messageData = {message: "wwwjdic_gloss", gloss: matchingGloss, 
				formattedGloss: formatGloss(matchingGloss), temp_id: thisXHR.temp_id};
			thisXHR.port.postMessage(messageData);
			localStorage.setItem("WWWJDIC_GLOSS-" + thisXHR.word + "-" + thisXHR.yomi, matchingGloss);
		} else if (thisXHR.dict == "1"/*EDICT*/) {	//Edict is the first, default dictionary that is searched.
			//Search again using "P", the expanded text gloss dict
			getWWWJDICEntry(thisXHR.port, thisXHR.word, thisXHR.yomi, thisXHR.temp_id, "P"/* P = expanded text gloss dict */);
		} else {
			var messageData = {message: "wwwjdic_gloss", gloss: null, temp_id: thisXHR.temp_id};
			thisXHR.port.postMessage(messageData);
		}
	}
}

//See http://www.csse.monash.edu.au/~jwb/edict_doc.html for dictionary format explanation
//Sample gloss result: " /(n) (1) teacher/master/doctor/(suf) (2) with names of teachers, etc. as an honorific/(P)/"
// Noun, 1st sense
//   teacher
//   master
//   doctor
// Suffix, 2nd sense
//   with names of teachers, etc. as an honorific
// Flagged as a 'Priority' word (one of the most commonly used 20,000)
function formatGloss(rawGloss) {
	var glossObj = { sense: new Array(), pos: new Array(), generalInfo: new Array() };
	var senses = new Array();
	var glossParts = rawGloss.match(/[^\/]+/g);
	var currSense = 1;
	var tempMatches;
	for (var x = 0; x < glossParts.length; x++) {
		currGlossPart = glossParts[x];
		if (tempMatches = currGlossPart.match(/^(?:\([^\)]+\))?\s*\((\d{1,2})\)/))
			currSense = tempMatches[1];
		if (!senses[currSense])
			senses[currSense] = {vals: new Array(), generalInfo: ""};
		if (tempMatches = currGlossPart.match(/^\(([^\)]+)\)/))
			senses[currSense].generalInfo += (senses[currSense].generalInfo ? "," : "") + tempMatches[1];
		if (tempMatches = currGlossPart.match(/^\(([^\)]+)\)\s*$/))	//e.g. when it's just "/(P)/"
			continue;
		tempMatches = currGlossPart.match(/^(\([^\)]+\)\s*)?(\([^\)]+\)\s*)?(.+)$/);
if (!tempMatches) alert("failed to regex match ordinary part of " + currGlossPart);
		senses[currSense].vals.push(tempMatches[3]);
	}
	var htmlVal = "<ul>";
	for (var x = 1; x < senses.length; x++) {	//N.B. there is no 0'th item
		htmlVal += "<li" + (senses[x].generalInfo ? " info='" + senses[x].generalInfo + "'" : "") + ">" + 
			senses[x].vals.join("<br/>") + "</li>";
	}
	htmlVal += "</ul>";
	return htmlVal;
}


/*****************
 *	Chrome events
 *****************/
//Page action listener
chrome.pageActions["ToggleFurigana"].addListener(function(pageaction) {
	chrome.windows.getCurrent(function(currentWindow) {
		chrome.tabs.getSelected(currentWindow.id, function(currTab) {
			if (!serverUrl)	{
				alert("Furigana server is offline");
				return;
			}
			if (tabPorts[currTab.id])	//Todo: delete this if() and the alert if nobody ever reports it occuring.
				tabPorts[currTab.id].postMessage({message: "toggle_furigana"}); //will remove furigana if already processed.
			else
				alert("Sorry, Furigana Injector has had an error. After receiving the reply from the server it couldn't communicate with the tab, which is an internal Chrome extensions error.\n(N.b. If you know how to replicate this error please contact the developer.)");
		});
	});
});

//Extension requests listener. Used mainly by kanji_content_detect.js, but also by parser.js to init config values.
chrome.extension.onRequest.addListener(
	function(request, sender, sendResponseCallback) {
		if (request.message == "config_values_request") {
			sendResponseCallback({userKanjiList: localStorage.getItem("user_kanji_list"), includeLinkText: localStorage.getItem("include_link_text")});
		} else if (request.message == "init_tab_for_fi") {
			if (!serverUrl) {
				chrome.pageActions.enableForTab('ToggleFurigana', 
					{tabId: sender.tab.id, url: sender.tab.url, title: "Furigana server offline", iconId: disabledIconIdx});
			} else {
				chrome.pageActions.enableForTab('ToggleFurigana', 
						{tabId: sender.tab.id, url: sender.tab.url, title: "Insert furigana ...", iconId: defaultIconIdx});
				chrome.tabs.executeScript(sender.tab.id, {file: "parser.js"/*, allFrames: false*/});
			}
		} else {
			console.log("Programming error: a request with the unexpected \"message\" value \"" + request.message + "\" was received in the background page.");
		}
	});
  
//Extension connect() listener. Called everytime a new page is loaded ... in either a new tab or existing one.
//parser.js is the only script that has sends messages this way, and which has a listener on the other side.
chrome.extension.onConnect.addListener(function(port) {
	tabPorts[port.tab.id] = port;
	port.onDisconnect.addListener(function(disconnected_port) {
		var where = tabPorts ? tabPorts.indexOf(disconnected_port) : -1;
		if (where != -1) {
			tabPorts.splice(where, 1);
		}
	});
	//Devnote: there is a bug in the options page according to the open source for AdBlockPlus for Chrome.
	//  Basically the options page doesn't trigger the onDisconnect. Separate handling for it is necessary 
	//  if you want to avoid issues there.
	port.onMessage.addListener(function(data) {
		if (data.message && data.message == "text_to_furiganize") {
			startFuriganizeAJAX(data.textToFuriganize, port, data.keepAllRuby ? true : false);
			chrome.pageActions.enableForTab('ToggleFurigana', 
				{tabId: port.tab.id, url: port.tab.url, title: "Sending request to server...", iconId: processingIconIdx});
		} else if (data.message && data.message == "show_page_processed") {
			chrome.pageActions.enableForTab('ToggleFurigana', 
				{tabId: port.tab.id, url: port.tab.url, title: "Remove furigana ...", iconId: processedIconIdx});
		//} else if (data.message && data.message == "disablepageaction") {
		//	chrome.pageActions.enableForTab('ToggleFurigana', 
		//		{tabId: port.tab.id, url: port.tab.url, title: "Simple kanji only. Disabled for this page.", iconId: disabledIconIdx});
		} else if (data.message && data.message == "reset_page_action_icon") {
			chrome.pageActions.enableForTab('ToggleFurigana', 
					{tabId: port.tab.id, url: port.tab.url, title: "Insert furigana ...", iconId: defaultIconIdx});
		} else if (data.message && data.message == "search_wwwjdic") {	
			getWWWJDICEntry(port, data.word, data.yomi, data.temp_id /*, dict (use default)*/);
		} else {
			console.log("Development error: unexpected message \"" + data.message + "\"");
		}
	});
});

//Storage events
window.addEventListener("storage",
	function(e) {
		if (e.key == "user_kanji_list") {	//re-initialize the data in each tab.
			//N.B. localStorage.getItem("user_kanji_list")) will equal e.newValue, not e.oldValue
			userKanjiRegexp = new RegExp("[" + localStorage.getItem("user_kanji_list") + "]");
		}
	}, false);
</script>
</head>
<body>
</body>
</html>
